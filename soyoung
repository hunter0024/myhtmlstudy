1개더는 그냥 글쓰기해주면됨

https://uareo.imweb.me/77?preview_mode=1

1. 촬영시작시간이 몇시인가요?

촬영시간은 일몰시간을 기준으로 정해지며, 계절에 따라 조금씩 차이가 있습니다.  정확한 시간안내는 촬영 하루이틀전 카톡으로 안내드리고 있으며 아래에 안내드리는 시간은 대략적인 시간입니다.

​

- 오전촬영상품(A타입 or 오전B타입) : 헤메를 추가했을시 헤메샵에 대략 오전 6시30분~7시 도착하셔야 하며, 촬영시작시간은 9시정도 입니다.

​

- 오후촬영상품  (C타입 or S타입) : 헤메샵에 대략 9시경 도착하셔서 헤메 및 드레스피팅 후 촬영시작시간은 대략 오후 1시경 입니다.

                           (오후B타입)       : 헤메샵에 대략 11시경 도착하셔서 헤메 및 드레스피팅 후 촬영시작은 대략 오후 3시경입니다.

​

​

​

2. 제휴업체 '유아오' '라르아'에  따로 문의 필요 한가요 ?

- '유아오'와 '라르아'연계가 되어있기때문에 헬퍼훈의 모든 상품예약시 따로 연락을 하지 않으셔도 자동적으로 예약이 되어 있습니다. 

​

​

​

3. 남성수트가 포함되어 있나요 ?

- 헬퍼훈의 모든상품에는 남성수트가 미포함입니다. 대여를 원하시면 남성수트 제휴업체인 '홀스테일러' 연락처를 안내드리고 있으며 , 직접 연락 후 예약이 필요합니다.  

​

​

​

4. 구두대여가 가능한가요 ? 

- 신부님 구두는 '유아오'에서 유상(1만원) 으로 대여 가능하시며, 신랑님 구두는 '홀스테일러'에 따로 문의가 필요합니다.

​

​

​

5. 헬퍼가 꼭 필요한가요 ? 

- 헬퍼실장님은 제주스냅촬영의 꽃이라 할 수 있는 헤어생화장식 및 헤어메이크업수정, 스타일링변형, 의상환복등 다양한 컨셉으로  촬영이 가능하게 도와주시며, 제주도의 특성상 바람이 많이 불기때문에 바람에 날리는 머리카락, 잔머리, 신랑님 신부님 의상라인등(보정불가) 여러부분에서 신경을 써주시고 계십니다. 특히 3시간이상 촬영하시는 신부님들께는 필수로 추천드리고 있습니다. 

​

​

​

6. 제주도에 당일도착해도 괜찮은가요 ?

- 오전촬영이 아닌 오후촬영이라고해도 헤어메이크업 및 드레스피팅이 모두 촬영 당일에 진행되기 때문에 전날 제주도에 도착하시는걸 추천드리며, 당일 도착하셔서 비행기연착, 렌터카등 여러가지 이유로 샵에 늦게 도착해 스케줄이 밀려 촬영시작이 늦게 되면 그만큼 촬영시간이 줄어들게 됩니다. 

​

​

​

7. 숙소 추천 ?

- 숙소는 제휴업체인 '유난히 아름다운 오늘' , ‘라르아’ 근처로 추천드려요. 

​

​

​

8. 드레스피팅은 언제하나요 ?

- 드레스 피팅은 모두 촬영 당일에 진행됩니다.

​

​

​

9. 이동시간 및 환복시간 ?

- 촬영시간안에 이동시간 및 드레스환복,헤어변형이 모두 포함되어있기때문에 너무 많은 변형시 촬영시간이 줄어들게 됩니다.

(헤어변형은 3시간기준 1번, 4-5시간 기준 2-3번 추천드려요.)

 

​

​

10. 날씨 및 꽃배경은 언제가 가장 좋을까요 ?

- 특정 날짜의 날씨나 꽃같은 경우 , 매년 날씨도 다르고 꽃은 개화나 만개시기가 날씨에 따라 달라지기때문에 정확하게 말씀드리기가 어려우며, 꽃배경으로 촬영을 원하셔도 제주도의 날씨나 현지 업체의 상황에 따라 촬영이 어려울수도 있는점 양해부탁드립니다.

▸ 성함 : 



▸ 연락처 : 



▸ 상품타입 : 



▸ B타입의 경우 오전 or 오후 시간대 필수기재  : 



▸ 원하시는 날짜 :



정확한 날짜를 말씀해주셔야 상담이 가능합니다. 

3월 셋째주 평일 or 주말 등 대략적으로라도 작성부탁드려요.




<script>
function _getClosest(item, array, getDiff) {
    var closest,
        diff;

    if (!Array.isArray(array)) {
        throw new Error("Get closest expects an array as second argument");
    }

    array.forEach(function (comparedItem, comparedItemIndex) {
        var thisDiff = getDiff(comparedItem, item);

        if (thisDiff >= 0 && (typeof diff == "undefined" || thisDiff < diff)) {
            diff = thisDiff;
            closest = comparedItemIndex;
        }
    });

    return closest;
}

function number(item, array) {
  return _getClosest(item, array, function (comparedItem, item) {
    return Math.abs(comparedItem - item);
  });
}
    
function lerp(a, b, n) {
    return (1 - n) * a + n * b
}

class Slider {
  constructor(options = {}) {
    this.bind()
    
    this.opts = {
      el: options.el || '.js-slider',
      ease: options.ease || 0.1,
      speed: options.speed || 1.5,
      velocity: 25,
      scroll: options.scroll || false
    }
    
    this.slider = document.querySelector('.js-slider')
    this.sliderInner = this.slider.querySelector('.js-slider__inner')
    this.slides = [...this.slider.querySelectorAll('.js-slide')]
    this.slidesNumb = this.slides.length
    
    this.rAF = undefined
    
    this.sliderWidth = 0
    
    this.onX = 0
    this.offX = 0
    
    this.currentX = 0
    this.lastX = 0
    
    this.min = 0
    this.max = 0

    this.centerX = window.innerWidth / 2
  }
  
  bind() {
    ['setPos', 'run', 'on', 'off', 'resize'].forEach((fn) => this[fn] = this[fn].bind(this))
  }
  
  setBounds() {
    const bounds = this.slides[0].getBoundingClientRect()
    const slideWidth = bounds.width

    this.sliderWidth = this.slidesNumb * slideWidth
    this.max = -(this.sliderWidth - window.innerWidth)
    
    this.slides.forEach((slide, index) => {
      slide.style.left = `${index * slideWidth}px`
    })
  }
  
  setPos(e) {
    if (!this.isDragging) return
    this.currentX = this.offX + ((e.clientX - this.onX) * this.opts.speed)
    this.clamp()
  }

  clamp() {
    this.currentX = Math.max(Math.min(this.currentX, this.min), this.max)
  }
  
  run() {
    this.lastX = lerp(this.lastX, this.currentX, this.opts.ease)
    this.lastX = Math.floor(this.lastX * 100) / 100 

    const sd = this.currentX - this.lastX
    const acc = sd / window.innerWidth
    let velo =+ acc
    
    this.sliderInner.style.transform = `translate3d(${this.lastX}px, 0, 0) skewX(${velo * this.opts.velocity}deg)`

    this.requestAnimationFrame()
  }
  
  on(e) {
    this.isDragging = true
    this.onX = e.clientX
    this.slider.classList.add('is-grabbing')
  }
  
  off(e) {
    this.snap()
    this.isDragging = false
    this.offX = this.currentX
    this.slider.classList.remove('is-grabbing')
  }
  
  closest() {
    const numbers = []
    this.slides.forEach((slide, index) => {
      const bounds = slide.getBoundingClientRect()
      const diff = this.currentX - this.lastX
      const center = (bounds.x + diff) + (bounds.width / 2)
      const fromCenter = this.centerX - center
      numbers.push(fromCenter)
    })

    let closest = number(0, numbers)
    closest = numbers[closest]
    
    return {
      closest
    }
  }

  snap() {
    const { closest } = this.closest()
    
    this.currentX = this.currentX + closest
    this.clamp()
  }

  requestAnimationFrame() {
    this.rAF = requestAnimationFrame(this.run)
  }

  cancelAnimationFrame() {
    cancelAnimationFrame(this.rAF)
  }
  
  addEvents() {
    this.run()
    
    this.slider.addEventListener('mousemove', this.setPos, { passive: true })
    this.slider.addEventListener('mousedown', this.on, false)
    this.slider.addEventListener('mouseup', this.off, false)
    
    window.addEventListener('resize', this.resize, false)
  }
  
  removeEvents() {
    this.cancelAnimationFrame(this.rAF)
    
    this.slider.removeEventListener('mousemove', this.setPos, { passive: true })
    this.slider.removeEventListener('mousedown', this.on, false)
    this.slider.removeEventListener('mouseup', this.off, false)
  }
  
  resize() {
    this.setBounds()
  }
  
  destroy() {
    this.removeEvents()
    
    this.opts = {}
  }
  
  init() {
    this.setBounds()
    this.addEvents()
  }
}

const slider = new Slider()
slider.init()
  
  
</script>
